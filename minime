#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Â© 2013  Nils Dagsson Moskopp (erlehmann)

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

# Dieses Programm hat das Ziel, die Medienkompetenz der Leser zu
# steigern. Gelegentlich packe ich sogar einen handfesten Buffer
# Overflow oder eine Format String Vulnerability zwischen die anderen
# Codezeilen und schreibe das auch nicht dran.

import string
import subprocess
import sys

from urwid import AttrWrap, CompositeCanvas, Edit, Filler, Frame, \
    MainLoop, Text, widget
from urwid.widget import apply_text_layout, move_next_char, move_prev_char

def move_prev_word(text, start_offs, end_offs):
    while(end_offs!=0):
        if text[end_offs-1] in string.whitespace:
            break
        end_offs-=1
    return end_offs

def move_next_word(text, start_offs, end_offs):
    while(start_offs!=len(text)):
        if text[start_offs] in string.whitespace:
            break
        start_offs+=1
    return start_offs

class Buffer(Edit):
    def keypress(self, size, key):
        # Unix Keyboard Shortcuts <http://unix-kb.cat-v.org/>
        if key == 'ctrl h':
            key = 'backspace'
        elif key == 'ctrl a':
            key = 'home'
        elif key == 'ctrl e':
            key = 'end'
        elif key == 'shift left':
            p = self.edit_pos
            if p==0:
                return key
            p = move_prev_char(self.edit_text,0,p)
            self.set_edit_pos_keep_highlight(p)
            if self.highlight:
                start, stop = self.highlight
                if p == start:
                    self.highlight = None
                elif start < p < stop:
                    self.highlight = (start, stop-1)
                elif p < start:
                    self.highlight = (start-1, stop)
            else:
                self.highlight = (p, p+1)
            self._invalidate()
        elif key == 'shift right':
            p = self.edit_pos
            if p >= len(self.edit_text):
                return key
            p = move_next_char(self.edit_text,p,len(self.edit_text))
            self.set_edit_pos_keep_highlight(p)
            if self.highlight:
                start, stop = self.highlight
                if p == stop:
                    self.highlight = None
                elif start < p < stop:
                    self.highlight = (start+1, stop)
                elif p > stop:
                    self.highlight = (start, stop+1)
            else:
                self.highlight = (p-1, p)
            self._invalidate()
        elif key == 'ctrl left':
            p = self.edit_pos
            if p==0:
                return key
            p = move_prev_word(self.edit_text,0,p-1)
            self.set_edit_pos(p)
        elif key == 'ctrl right':
            p = self.edit_pos
            if p>=len(self.edit_text):
                return key
            p = move_next_word(self.edit_text,p+1,len(self.edit_text))
            self.set_edit_pos(p)

        return super(Buffer, self).keypress(size, key)

    def render(self, size, focus=False):
        """
        Render buffer widget and return canvas. Always include cursor.
        """
        (maxcol,)=size
        self._shift_view_to_cursor = True
        text, attr = self.get_text()
        if self.highlight:
            start, stop = self.highlight
            attr = [(None, start), ('reverse', stop-start)]
        trans = self.get_line_translation(maxcol, (text, attr))
        canvas = apply_text_layout(text, attr, trans, maxcol)
        canvas = CompositeCanvas(canvas)
        canvas.cursor = self.get_cursor_coords((maxcol,))
        return canvas

    def set_edit_pos_keep_highlight(self, pos):
        highlight = self.highlight
        super(Buffer, self).set_edit_pos(pos)
        self.highlight = highlight

palette = [ ('reverse', 'black', 'white') ]
mainbuffer = Buffer(edit_text=u'', multiline=True, align='left')
mainfiller = Filler(mainbuffer, valign='top')
minibuffer = Edit(edit_text=u'', multiline=False, align='left')
mini_attr = AttrWrap(minibuffer, 'reverse')
frame = Frame(body=mainfiller, footer=mini_attr, focus_part='body')

def handle_external_command(command, text):
    process = subprocess.Popen([command], stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE, shell=True)
    process.stdin.write(text.encode('utf-8'))
    process.stdin.close()
    result = process.stdout.read().decode('utf-8')
    if text == u'':
        mainbuffer.insert_text(result)
    else:
        mainbuffer.set_edit_text(result)
    minibuffer.set_edit_text(u'')

def get_file(argument):
    result = u''
    try:
        with open(argument, 'r') as inputfile:
            result = inputfile.read().decode('utf-8')
            mainbuffer.set_edit_text(result)
            minibuffer.set_edit_text(argument)
            minibuffer.set_edit_pos(0)
    except IOError:
        pass

def put_file(argument, text):
    try:
        with open(argument, 'w') as outputfile:
            outputfile.write(text.encode('utf-8'))
            minibuffer.set_edit_text(argument)
            minibuffer.set_edit_pos(0)
    except IOError:
        pass

def handle_command(command, text):
    try:
        prefix, argument = command[0], command[1:]
    except IndexError:
        return
    if prefix == '<':
        get_file(argument)
    elif prefix == '>':
        put_file(argument, text)
    elif prefix == '|':
        handle_external_command(argument, text)
    else:
        handle_external_command(command, u'')
    frame.set_focus('body')

def word_at_pos(text, pos):
    start = end = pos
    while(start!=0):
        if text[start-1] in string.whitespace:
            break
        start-=1
    while(end!=len(text)):
        if text[end] in string.whitespace:
            break
        end+=1
    return text[start:end]

def handle_input(key):
    focus = frame.get_focus()
    maintext, minitext = mainbuffer.get_text()[0], minibuffer.get_text()[0]
    if key == 'enter':
        if focus == 'footer':
            handle_command(minitext, maintext)
    if key == 'tab':
        if focus == 'body':
            frame.set_focus('footer')
            if minitext == u'':
                current_word = word_at_pos(maintext, mainbuffer.edit_pos)
                minibuffer.set_edit_text(current_word)
        elif focus == 'footer':
            frame.set_focus('body')

if __name__ == "__main__":
    loop = MainLoop(frame, palette=palette,
                          unhandled_input=handle_input)
    if len(sys.argv) > 1:
        get_file(sys.argv[1])
    loop.run()
