#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Â© 2013  Nils Dagsson Moskopp (erlehmann)

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

# Dieses Programm hat das Ziel, die Medienkompetenz der Leser zu
# steigern. Gelegentlich packe ich sogar einen handfesten Buffer
# Overflow oder eine Format String Vulnerability zwischen die anderen
# Codezeilen und schreibe das auch nicht dran.

import string
import subprocess
import sys

from urwid import AttrWrap, CompositeCanvas, Edit, Filler, Frame, \
    MainLoop, Text, widget
from urwid.widget import apply_text_layout, move_next_char, move_prev_char

def move_prev_word(text, start_offs, end_offs):
    while(end_offs!=0):
        if text[end_offs-1] in string.whitespace+string.punctuation:
            break
        end_offs-=1
    return end_offs

def move_next_word(text, start_offs, end_offs):
    while(start_offs!=len(text)):
        if text[start_offs] in string.whitespace+string.punctuation:
            break
        start_offs+=1
    return start_offs

class Buffer(Edit):
    def get_highlight_text(self):
        if self.highlight:
            start, stop = self.highlight
            return self.edit_text[start:stop]
        return u''

    def keypress(self, size, key):
        # Unix Keyboard Shortcuts <http://unix-kb.cat-v.org/>
        if key == 'ctrl h':
            key = 'backspace'
        elif key == 'ctrl a':
            key = 'home'
        elif key == 'ctrl e':
            key = 'end'
        elif key == 'shift left':
            p = self.edit_pos
            if p==0:
                return key
            p = move_prev_char(self.edit_text,0,p)
            self.set_edit_pos_keep_highlight(p)
            if self.highlight:
                start, stop = self.highlight
                if p == start:
                    self.highlight = None
                elif start < p < stop:
                    self.highlight = (start, stop-1)
                elif p < start:
                    self.highlight = (start-1, stop)
            else:
                self.highlight = (p, p+1)
            self._invalidate()
        elif key == 'shift right':
            p = self.edit_pos
            if p >= len(self.edit_text):
                return key
            p = move_next_char(self.edit_text,p,len(self.edit_text))
            self.set_edit_pos_keep_highlight(p)
            if self.highlight:
                start, stop = self.highlight
                if p == stop:
                    self.highlight = None
                elif start < p < stop:
                    self.highlight = (start+1, stop)
                elif p > stop:
                    self.highlight = (start, stop+1)
            else:
                self.highlight = (p-1, p)
            self._invalidate()
        elif key == 'ctrl left':
            p = self.edit_pos
            if p==0:
                return key
            p = move_prev_word(self.edit_text,0,p-1)
            self.set_edit_pos(p)
        elif key == 'ctrl right':
            p = self.edit_pos
            if p>=len(self.edit_text):
                return key
            p = move_next_word(self.edit_text,p+1,len(self.edit_text))
            self.set_edit_pos(p)
        elif key == 'shift meta left':
            p = self.edit_pos
            if p==0:
                return key
            q = move_prev_word(self.edit_text,0,p-1)
            self.set_edit_pos_keep_highlight(q)
            if self.highlight:
                start, stop = self.highlight
                if q == start:
                    self.highlight = None
                elif start < q < stop:
                    self.highlight = (start, stop-(p-q))
                elif q < p == start:
                    self.highlight = (start-(p-q), stop)
                elif q < start < p:
                    self.highlight = (q, start)
            else:
                self.highlight = (q, p)
            self._invalidate()
        elif key == 'shift meta right':
            p = self.edit_pos
            if p>=len(self.edit_text):
                return key
            q = move_next_word(self.edit_text,p+1,len(self.edit_text))
            self.set_edit_pos_keep_highlight(q)
            if self.highlight:
                start, stop = self.highlight
                if q == stop:
                    self.highlight = None
                elif start < q < stop:
                    self.highlight = (start+(q-p), stop)
                elif p == stop < q:
                    self.highlight = (start, stop+(q-p))
                elif p < stop < q:
                    self.highlight = (stop, q)
            else:
                self.highlight = (p, q)
            self._invalidate()


        return super(Buffer, self).keypress(size, key)

    def render(self, size, focus=False):
        """
        Render buffer widget and return canvas. Always include cursor.
        """
        (maxcol,)=size
        self._shift_view_to_cursor = True
        text, attr = self.get_text()
        if self.highlight:
            start, stop = self.highlight
            attr = [(None, start), ('reverse', stop-start)]
        trans = self.get_line_translation(maxcol, (text, attr))
        canvas = apply_text_layout(text, attr, trans, maxcol)
        canvas = CompositeCanvas(canvas)
        canvas.cursor = self.get_cursor_coords((maxcol,))
        return canvas

    def set_edit_pos_keep_highlight(self, pos):
        highlight = self.highlight
        super(Buffer, self).set_edit_pos(pos)
        self.highlight = highlight

palette = [ ('reverse', 'black', 'white') ]
mainbuffer = Buffer(edit_text=u'', multiline=True, align='left')
mainfiller = Filler(mainbuffer, valign='top')
minibuffer = Edit(edit_text=u'', multiline=False, align='left')
mini_attr = AttrWrap(minibuffer, 'reverse')
frame = Frame(body=mainfiller, footer=mini_attr, focus_part='body')

def handle_external_command(command, text):
    process = subprocess.Popen([command], stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE, shell=True)
    process.stdin.write(text.encode('utf-8'))
    process.stdin.close()
    result = process.stdout.read().decode('utf-8')
    return result

def handle_command(command):
    try:
        prefix, argument = command[0], command[1:]
    except IndexError:
        return
    if prefix == '#':
        try:
            p=int(argument)
            mainbuffer.set_edit_pos(p)
        except ValueError:
            pass
    elif prefix == '<':  # replace selection by stdout of command
        inputtext = handle_external_command(argument, u'')
        mainbuffer.insert_text(inputtext)
    elif prefix == '>':  # send selection to stdin of command
        outputtext = mainbuffer.get_highlight_text()
        handle_external_command(argument, outputtext)
    elif prefix == '|':  # replace selection by stdout of command
        inputtext = mainbuffer.get_highlight_text()
        outputtext = handle_external_command(argument, inputtext)
        mainbuffer.insert_text(outputtext)
    elif prefix == '!':  # run command
        handle_external_command(argument, u'')
    minibuffer.set_edit_text(argument)
    minibuffer.set_edit_pos(0)
    frame.set_focus('body')

def handle_input(key):
    focus = frame.get_focus()
    if key == 'enter':
        if focus == 'footer':
            command = minibuffer.get_text()[0]
            handle_command(command)
    if key == 'tab':
        if focus == 'body':
            frame.set_focus('footer')
        elif focus == 'footer':
            frame.set_focus('body')

if __name__ == "__main__":
    loop = MainLoop(frame, palette=palette,
                          unhandled_input=handle_input)
    if len(sys.argv) > 1:
        with open(sys.argv[1]) as inputfile:
            inputtext = inputfile.read().decode('utf-8')
            mainbuffer.insert_text(inputtext)
            mainbuffer.set_edit_pos(0)
    loop.run()
